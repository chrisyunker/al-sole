<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Al Sole</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #2a2a2a 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .graph-container {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .graph-toggle-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .toggle-btn {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .toggle-btn.active {
            background: rgba(74, 222, 128, 0.3);
            border-color: #4ade80;
        }

        #distanceGraph {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .distance-display {
            text-align: center;
            margin: 30px 0;
        }

        .distance-value {
            font-size: 3em;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .distance-unit {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .info-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: bold;
        }

        .location-info {
            text-align: center;
            margin: 20px 0;
            opacity: 0.9;
            font-size: 0.95em;
        }

        .info-table-container {
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }

        .info-table {
            width: 100%;
            border-collapse: collapse;
        }

        .info-table tr {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-table tr:last-child {
            border-bottom: none;
        }

        .info-table-label {
            padding: 12px;
            text-align: left;
            opacity: 0.8;
            font-size: 0.95em;
            width: 50%;
        }

        .info-table-value {
            padding: 12px;
            text-align: right;
            font-weight: bold;
            font-size: 1.1em;
        }

        .status {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 15px 0;
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
        }

        .loading {
            background: rgba(255, 255, 0, 0.2);
        }

        .button {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .update-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ade80;
            display: inline-block;
            margin-left: 5px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            overflow-y: auto;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            margin: 50px auto;
            padding: 30px;
            border-radius: 15px;
            max-width: 800px;
            width: 90%;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.18);
            position: relative;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .close {
            color: #fff;
            float: right;
            font-size: 32px;
            font-weight: bold;
            line-height: 24px;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close:hover {
            color: #ffcc00;
        }

        .modal-content h2 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 2em;
            text-align: center;
        }

        .modal-content h3 {
            color: #fff;
            margin-top: 25px;
            margin-bottom: 10px;
            font-size: 1.4em;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }

        .modal-content p {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #4ade80;
        }

        .formula-title {
            color: #4ade80;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .variable {
            color: #fbbf24;
            font-weight: bold;
        }

        .info-button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .info-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .comparison-section {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .comparison-section h3 {
            font-size: 1.1em;
            margin-bottom: 15px;
            text-align: center;
        }

        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .input-field {
            flex: 1;
            min-width: 80px;
        }

        .input-field label {
            display: block;
            font-size: 0.85em;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .input-field input {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            font-size: 0.9em;
        }

        .input-field input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .input-field select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            font-size: 0.9em;
            cursor: pointer;
        }

        .input-field select option {
            background: #1a1a1a;
            color: white;
            padding: 8px;
        }

        .add-location-btn {
            padding: 10px 20px;
            background: rgba(74, 222, 128, 0.3);
            border: 1px solid #4ade80;
            border-radius: 6px;
            color: white;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
        }

        .add-location-btn:hover {
            background: rgba(74, 222, 128, 0.5);
        }

        .comparison-locations {
            margin-top: 15px;
        }

        .location-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            border-left: 4px solid;
        }

        .location-label {
            flex: 1;
            font-size: 0.9em;
        }

        .remove-btn {
            padding: 5px 15px;
            background: rgba(255, 0, 0, 0.3);
            border: 1px solid rgba(255, 0, 0, 0.5);
            border-radius: 4px;
            color: white;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .remove-btn:hover {
            background: rgba(255, 0, 0, 0.5);
        }

        .graph-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 10px;
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2em;
            }

            .distance-value {
                font-size: 2.2em;
            }

            .container {
                padding: 25px;
            }

            .graph-container {
                padding: 10px;
            }

            .toggle-btn {
                padding: 6px 15px;
                font-size: 0.85em;
            }

            #distanceGraph {
                max-width: 100%;
                height: auto;
            }

            .info-grid {
                gap: 10px;
            }

            .info-card {
                padding: 12px;
            }

            .modal-content {
                margin: 20px auto;
                padding: 20px;
                width: 95%;
            }

            .modal-content h2 {
                font-size: 1.5em;
            }

            .modal-content h3 {
                font-size: 1.2em;
            }
        }
    </style>


  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y5CZBN42C4"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-Y5CZBN42C4');
  </script>

</head>
<body>
    <div class="container">
        <h1>Al Sole</h1>

        <div id="status" class="status loading">
            Requesting location access...
        </div>

        <div id="mainContent" style="display: none;">
            <div class="info-table-container">
                <table class="info-table">
                    <tr>
                        <td class="info-table-label">Local Time</td>
                        <td class="info-table-value" id="localTime">-</td>
                    </tr>
                    <tr>
                        <td class="info-table-label">Solar Noon Offset</td>
                        <td class="info-table-value" id="solarNoon">-</td>
                    </tr>
                    <tr>
                        <td class="info-table-label">Location</td>
                        <td class="info-table-value" id="coordinates">-</td>
                    </tr>
                </table>
            </div>

            <div class="distance-display">
                <div class="distance-unit" id="distanceUnitLabel" style="font-size: 1.8em;">
                    You are <span class="distance-value" id="distanceValue" style="display: inline; font-size: 1em; margin: 0;">-</span> kilometers from the Sun
                </div>
                <div style="margin-top: 10px;">
                    <span class="update-indicator"></span>
                </div>
            </div>

            <div class="graph-container">
                <h3 style="text-align: center; margin-bottom: 10px; font-size: 1.1em;">Distance from Sun & Solar Elevation Angle</h3>
                <div class="graph-toggle-buttons">
                    <button class="toggle-btn active" id="dailyViewBtn" onclick="setGraphView('daily')">24 Hours</button>
                    <button class="toggle-btn" id="yearlyViewBtn" onclick="setGraphView('yearly')">1 Year</button>
                </div>
                <div id="graphLegend" class="graph-legend"></div>
                <canvas id="distanceGraph" width="600" height="340"></canvas>
                <div style="display: flex; justify-content: center; gap: 10px; margin-top: 15px;">
                    <button class="toggle-btn active" id="kmBtn" onclick="setUnit('km')">Kilometers</button>
                    <button class="toggle-btn" id="milesBtn" onclick="setUnit('miles')">Miles</button>
                </div>
            </div>

            <div class="comparison-section" id="comparisonSection">
                <h3>Compare Locations</h3>
                <div class="input-row">
                    <div class="input-field" style="flex: 2;">
                        <label>Select a City</label>
                        <select id="citySelect">
                            <option value="">Choose a city...</option>
                        </select>
                    </div>
                </div>
                <div style="text-align: center; margin: 10px 0; opacity: 0.7; font-size: 0.9em;">or enter coordinates</div>
                <div class="input-row">
                    <div class="input-field">
                        <label>Latitude (-90 to 90)</label>
                        <input type="number" id="customLat" placeholder="e.g. 40.7128" step="0.0001" min="-90" max="90">
                    </div>
                    <div class="input-field">
                        <label>Longitude (-180 to 180)</label>
                        <input type="number" id="customLon" placeholder="e.g. -74.0060" step="0.0001" min="-180" max="180">
                    </div>
                </div>
                <button class="add-location-btn" onclick="addComparisonLocation()">Add Location</button>
                <div id="comparisonLocations" class="comparison-locations"></div>
            </div>

            <button class="info-button" onclick="openModal()" style="width: 100%; margin-top: 5px;">üìê View Formulas</button>
        </div>
    </div>

    <!-- Formula Modal -->
    <div id="formulaModal" class="modal" onclick="closeModalOnOutsideClick(event)">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>üìê Distance Calculation Formulas</h2>

            <h3>1. Earth-Sun Distance</h3>
            <p>Earth's orbit around the Sun is elliptical, not circular. The distance varies throughout the year:</p>

            <div class="formula">
                <div class="formula-title">Base Formula:</div>
                <span class="variable">distance</span> = <span class="variable">AU</span> √ó (1 - <span class="variable">e</span> √ó cos(<span class="variable">M</span>))
            </div>

            <p><strong>Where:</strong></p>
            <p>
                ‚Ä¢ <span class="variable">AU</span> = 149,597,870.7 km (Astronomical Unit, average Earth-Sun distance)<br>
                ‚Ä¢ <span class="variable">e</span> = 0.0167 (eccentricity of Earth's orbit)<br>
                ‚Ä¢ <span class="variable">M</span> = Mean Anomaly (angle from perihelion)
            </p>

            <div class="formula">
                <div class="formula-title">Mean Anomaly Calculation:</div>
                <span class="variable">M</span> = (2œÄ √ó <span class="variable">daysSincePerihelion</span>) / 365.25
            </div>

            <p>
                ‚Ä¢ Perihelion (closest point) occurs around January 3<br>
                ‚Ä¢ Aphelion (farthest point) occurs around July 4<br>
                ‚Ä¢ This creates a ~5 million km variation in Earth-Sun distance
            </p>

            <h3>2. Your Distance Offset</h3>
            <p>Your personal distance from the Sun varies based on your position on Earth's surface and the time of day:</p>

            <div class="formula">
                <div class="formula-title">User Offset:</div>
                <span class="variable">offset</span> = <span class="variable">R</span> √ó cos(<span class="variable">lat</span>) √ó cos(<span class="variable">H</span>)
            </div>

            <p><strong>Where:</strong></p>
            <p>
                ‚Ä¢ <span class="variable">R</span> = 6,371 km (Earth's radius)<br>
                ‚Ä¢ <span class="variable">lat</span> = your latitude in radians<br>
                ‚Ä¢ <span class="variable">H</span> = solar hour angle (your rotation position)
            </p>

            <div class="formula">
                <div class="formula-title">Solar Hour Angle:</div>
                <span class="variable">H</span> = ((UTC_hours - 12) √ó 15 + <span class="variable">longitude</span>) √ó œÄ/180
            </div>

            <p>
                ‚Ä¢ Earth rotates 15 degrees per hour (360¬∞/24h)<br>
                ‚Ä¢ At solar noon (H = 0¬∞): you're closest to the Sun<br>
                ‚Ä¢ At solar midnight (H = 180¬∞): you're farthest from the Sun<br>
                ‚Ä¢ Maximum variation: ~12,742 km (Earth's diameter)
            </p>

            <div class="formula">
                <div class="formula-title">Final User Distance:</div>
                <span class="variable">userDistance</span> = <span class="variable">earthSunDistance</span> - <span class="variable">offset</span>
            </div>

            <h3>3. Day/Night Determination</h3>
            <p>Whether you're facing the Sun (day) or away from it (night):</p>

            <div class="formula">
                <div class="formula-title">Day Condition:</div>
                -90¬∞ ‚â§ <span class="variable">solarHourAngle</span> ‚â§ 90¬∞ ‚Üí Day<br>
                Otherwise ‚Üí Night
            </div>

            <h3>4. Solar Noon Offset</h3>
            <p>Solar noon occurs when the Sun is highest in your sky:</p>

            <div class="formula">
                <div class="formula-title">Solar Noon (UTC):</div>
                <span class="variable">solarNoon</span> = 12 - (<span class="variable">longitude</span> / 15)
            </div>

            <p>
                ‚Ä¢ Each 15¬∞ of longitude = 1 hour time difference<br>
                ‚Ä¢ This doesn't account for time zones or daylight saving time<br>
                ‚Ä¢ It represents true solar time based on Earth's rotation
            </p>

            <h3>Real-Time Updates</h3>
            <p>This application recalculates all values every 100 milliseconds to show how your distance changes in real-time as Earth rotates on its axis. You can see the numbers change continuously!</p>

            <p style="text-align: center; margin-top: 30px; opacity: 0.8;">
                <em>All calculations use simplified astronomical models suitable for educational purposes.</em>
            </p>
        </div>
    </div>

    <script>
        let userLat = null;
        let userLon = null;
        let updateInterval = null;
        let currentGraphView = 'daily'; // 'daily' or 'yearly'
        let currentUnit = 'km'; // 'km' or 'miles'
        let graphData = [];
        let elevationData = [];
        let canvas = null;
        let ctx = null;
        let comparisonLocations = [];
        const colorPalette = ['#4ade80', '#ff6b6b', '#4ecdc4', '#ffd93d', '#a78bfa'];
        const MAX_LOCATIONS = 4;

        // Preset cities around the world
        const cities = [
            // North America
            { name: "New York, USA", lat: 40.7128, lon: -74.0060 },
            { name: "Los Angeles, USA", lat: 34.0522, lon: -118.2437 },
            { name: "Chicago, USA", lat: 41.8781, lon: -87.6298 },
            { name: "Houston, USA", lat: 29.7604, lon: -95.3698 },
            { name: "Miami, USA", lat: 25.7617, lon: -80.1918 },
            { name: "Seattle, USA", lat: 47.6062, lon: -122.3321 },
            { name: "San Francisco, USA", lat: 37.7749, lon: -122.4194 },
            { name: "Toronto, Canada", lat: 43.6532, lon: -79.3832 },
            { name: "Vancouver, Canada", lat: 49.2827, lon: -123.1207 },
            { name: "Mexico City, Mexico", lat: 19.4326, lon: -99.1332 },
            { name: "Guadalajara, Mexico", lat: 20.6597, lon: -103.3496 },

            // South America
            { name: "S√£o Paulo, Brazil", lat: -23.5505, lon: -46.6333 },
            { name: "Rio de Janeiro, Brazil", lat: -22.9068, lon: -43.1729 },
            { name: "Buenos Aires, Argentina", lat: -34.6037, lon: -58.3816 },
            { name: "Lima, Peru", lat: -12.0464, lon: -77.0428 },
            { name: "Bogot√°, Colombia", lat: 4.7110, lon: -74.0721 },
            { name: "Santiago, Chile", lat: -33.4489, lon: -70.6693 },
            { name: "Caracas, Venezuela", lat: 10.4806, lon: -66.9036 },

            // Europe
            { name: "London, UK", lat: 51.5074, lon: -0.1278 },
            { name: "Paris, France", lat: 48.8566, lon: 2.3522 },
            { name: "Berlin, Germany", lat: 52.5200, lon: 13.4050 },
            { name: "Madrid, Spain", lat: 40.4168, lon: -3.7038 },
            { name: "Rome, Italy", lat: 41.9028, lon: 12.4964 },
            { name: "Amsterdam, Netherlands", lat: 52.3676, lon: 4.9041 },
            { name: "Stockholm, Sweden", lat: 59.3293, lon: 18.0686 },
            { name: "Oslo, Norway", lat: 59.9139, lon: 10.7522 },
            { name: "Copenhagen, Denmark", lat: 55.6761, lon: 12.5683 },
            { name: "Helsinki, Finland", lat: 60.1695, lon: 24.9354 },
            { name: "Reykjavik, Iceland", lat: 64.1466, lon: -21.9426 },
            { name: "Dublin, Ireland", lat: 53.3498, lon: -6.2603 },
            { name: "Lisbon, Portugal", lat: 38.7223, lon: -9.1393 },
            { name: "Athens, Greece", lat: 37.9838, lon: 23.7275 },
            { name: "Moscow, Russia", lat: 55.7558, lon: 37.6173 },
            { name: "Istanbul, Turkey", lat: 41.0082, lon: 28.9784 },
            { name: "Vienna, Austria", lat: 48.2082, lon: 16.3738 },
            { name: "Prague, Czech Republic", lat: 50.0755, lon: 14.4378 },
            { name: "Warsaw, Poland", lat: 52.2297, lon: 21.0122 },

            // Asia
            { name: "Tokyo, Japan", lat: 35.6762, lon: 139.6503 },
            { name: "Beijing, China", lat: 39.9042, lon: 116.4074 },
            { name: "Shanghai, China", lat: 31.2304, lon: 121.4737 },
            { name: "Hong Kong", lat: 22.3193, lon: 114.1694 },
            { name: "Seoul, South Korea", lat: 37.5665, lon: 126.9780 },
            { name: "Singapore", lat: 1.3521, lon: 103.8198 },
            { name: "Bangkok, Thailand", lat: 13.7563, lon: 100.5018 },
            { name: "Mumbai, India", lat: 19.0760, lon: 72.8777 },
            { name: "Delhi, India", lat: 28.7041, lon: 77.1025 },
            { name: "Bangalore, India", lat: 12.9716, lon: 77.5946 },
            { name: "Dubai, UAE", lat: 25.2048, lon: 55.2708 },
            { name: "Tel Aviv, Israel", lat: 32.0853, lon: 34.7818 },
            { name: "Jakarta, Indonesia", lat: -6.2088, lon: 106.8456 },
            { name: "Manila, Philippines", lat: 14.5995, lon: 120.9842 },
            { name: "Kuala Lumpur, Malaysia", lat: 3.1390, lon: 101.6869 },
            { name: "Ho Chi Minh City, Vietnam", lat: 10.8231, lon: 106.6297 },
            { name: "Taipei, Taiwan", lat: 25.0330, lon: 121.5654 },

            // Africa
            { name: "Cairo, Egypt", lat: 30.0444, lon: 31.2357 },
            { name: "Lagos, Nigeria", lat: 6.5244, lon: 3.3792 },
            { name: "Johannesburg, South Africa", lat: -26.2041, lon: 28.0473 },
            { name: "Cape Town, South Africa", lat: -33.9249, lon: 18.4241 },
            { name: "Nairobi, Kenya", lat: -1.2921, lon: 36.8219 },
            { name: "Casablanca, Morocco", lat: 33.5731, lon: -7.5898 },
            { name: "Addis Ababa, Ethiopia", lat: 9.0320, lon: 38.7469 },
            { name: "Accra, Ghana", lat: 5.6037, lon: -0.1870 },

            // Oceania
            { name: "Sydney, Australia", lat: -33.8688, lon: 151.2093 },
            { name: "Melbourne, Australia", lat: -37.8136, lon: 144.9631 },
            { name: "Brisbane, Australia", lat: -27.4698, lon: 153.0251 },
            { name: "Perth, Australia", lat: -31.9505, lon: 115.8605 },
            { name: "Auckland, New Zealand", lat: -36.8485, lon: 174.7633 },
            { name: "Wellington, New Zealand", lat: -41.2865, lon: 174.7762 },

            // Additional Major Cities
            { name: "Karachi, Pakistan", lat: 24.8607, lon: 67.0011 },
            { name: "Dhaka, Bangladesh", lat: 23.8103, lon: 90.4125 },
            { name: "Kolkata, India", lat: 22.5726, lon: 88.3639 },
            { name: "Tehran, Iran", lat: 35.6892, lon: 51.3890 },
            { name: "Riyadh, Saudi Arabia", lat: 24.7136, lon: 46.6753 },
            { name: "Baghdad, Iraq", lat: 33.3152, lon: 44.3661 },
            { name: "Ankara, Turkey", lat: 39.9334, lon: 32.8597 },
            { name: "Kyiv, Ukraine", lat: 50.4501, lon: 30.5234 },
            { name: "Bucharest, Romania", lat: 44.4268, lon: 26.1025 },
            { name: "Budapest, Hungary", lat: 47.4979, lon: 19.0402 },
            { name: "Montreal, Canada", lat: 45.5017, lon: -73.5673 },
            { name: "Boston, USA", lat: 42.3601, lon: -71.0589 },
            { name: "Denver, USA", lat: 39.7392, lon: -104.9903 },
            { name: "Atlanta, USA", lat: 33.7490, lon: -84.3880 },
            { name: "Phoenix, USA", lat: 33.4484, lon: -112.0740 },
            { name: "Philadelphia, USA", lat: 39.9526, lon: -75.1652 },
            { name: "San Diego, USA", lat: 32.7157, lon: -117.1611 },
            { name: "Dallas, USA", lat: 32.7767, lon: -96.7970 },
            { name: "Las Vegas, USA", lat: 36.1699, lon: -115.1398 },
            { name: "Honolulu, USA", lat: 21.3099, lon: -157.8581 },
            { name: "Anchorage, USA", lat: 61.2181, lon: -149.9003 },
            { name: "Quito, Ecuador", lat: -0.1807, lon: -78.4678 },
            { name: "La Paz, Bolivia", lat: -16.5000, lon: -68.1500 },
            { name: "Montevideo, Uruguay", lat: -34.9011, lon: -56.1645 },
            { name: "Havana, Cuba", lat: 23.1136, lon: -82.3666 },
            { name: "Panama City, Panama", lat: 8.9824, lon: -79.5199 },
            { name: "San Jos√©, Costa Rica", lat: 9.9281, lon: -84.0907 },
        ];

        // Sort cities alphabetically
        cities.sort((a, b) => a.name.localeCompare(b.name));

        // Request user's location on page load
        window.addEventListener('load', () => {
            initGraph();
            populateCityDropdown();

            // Load saved unit preference from localStorage
            const savedUnit = localStorage.getItem('preferredUnit');
            if (savedUnit === 'miles') {
                setUnit('miles');
            }

            requestLocation();
        });

        // Populate city dropdown
        function populateCityDropdown() {
            const select = document.getElementById('citySelect');
            cities.forEach((city, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = city.name;
                select.appendChild(option);
            });
        }

        // Initialize graph canvas
        function initGraph() {
            canvas = document.getElementById('distanceGraph');
            if (canvas) {
                ctx = canvas.getContext('2d');
                canvas.width = 600;
                canvas.height = 340;
            }
        }

        // Generate daily view data (24 hours)
        function generateDailyData() {
            if (!userLat || !userLon) return [];

            const now = new Date();
            const dayOfYear = getDayOfYear(now);
            const earthSunDist = calculateEarthSunDistance(dayOfYear);

            // Create array of all locations (user + comparisons)
            const allLocations = [
                { lat: userLat, lon: userLon, label: 'Your Location', color: colorPalette[0] },
                ...comparisonLocations
            ];

            // Generate data for each location
            const series = allLocations.map(location => {
                const data = [];
                for (let hour = 0; hour < 24; hour++) {
                    const testTime = new Date(now);
                    testTime.setHours(hour, 0, 0, 0);
                    const distance = calculateUserDistanceFromSun(location.lat, location.lon, testTime, earthSunDist);
                    data.push({ x: hour, y: distance, label: hour + ':00' });
                }
                return {
                    location: location,
                    data: data
                };
            });

            return series;
        }

        // Generate yearly view data (365 days)
        function generateYearlyData() {
            if (!userLat || !userLon) return [];

            const now = new Date();
            const currentYear = now.getFullYear();

            // For yearly view, only show user location since orbital distance is the same
            // for all locations on Earth (comparison locations would show identical overlapping lines)
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            const data = [];
            for (let month = 0; month < 12; month++) {
                const testDate = new Date(currentYear, month, 15); // Mid-month
                const dayOfYear = getDayOfYear(testDate);
                const distance = calculateEarthSunDistance(dayOfYear);
                data.push({ x: month, y: distance, label: monthNames[month] });
            }

            // Return single series for user location
            return [{
                location: { lat: userLat, lon: userLon, label: 'Your Location', color: colorPalette[0] },
                data: data
            }];
        }

        // Generate elevation angle data (24 hours)
        function generateElevationData() {
            if (!userLat || !userLon) return [];

            const now = new Date();

            // Create array of all locations (user + comparisons)
            const allLocations = [
                { lat: userLat, lon: userLon, label: 'Your Location', color: colorPalette[0] },
                ...comparisonLocations
            ];

            // Generate data for each location
            const series = allLocations.map(location => {
                const data = [];
                for (let hour = 0; hour < 24; hour++) {
                    const testTime = new Date(now);
                    testTime.setHours(hour, 0, 0, 0);
                    const elevation = calculateSolarElevation(location.lat, location.lon, testTime);
                    data.push({ x: hour, y: elevation, label: hour + ':00' });
                }
                return {
                    location: location,
                    data: data
                };
            });

            return series;
        }

        // Generate yearly elevation data (12 months, at solar noon)
        function generateYearlyElevationData() {
            if (!userLat || !userLon) return [];

            const now = new Date();
            const currentYear = now.getFullYear();
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // Create array of all locations (user + comparisons)
            const allLocations = [
                { lat: userLat, lon: userLon, label: 'Your Location', color: colorPalette[0] },
                ...comparisonLocations
            ];

            // Generate data for each location
            const series = allLocations.map(location => {
                const data = [];
                for (let month = 0; month < 12; month++) {
                    // Use mid-month and solar noon (12:00 local solar time)
                    const testDate = new Date(currentYear, month, 15, 12, 0, 0);
                    const elevation = calculateSolarElevation(location.lat, location.lon, testDate);
                    data.push({ x: month, y: elevation, label: monthNames[month] });
                }
                return {
                    location: location,
                    data: data
                };
            });

            return series;
        }

        // Draw the graph
        function drawGraph() {
            if (!ctx || graphData.length === 0) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const paddingLeft = 80;
            const paddingRight = 80; // Increased for right Y-axis
            const paddingTop = 50;
            const paddingBottom = 50;
            const graphWidth = canvas.width - paddingLeft - paddingRight;
            const graphHeight = canvas.height - paddingTop - paddingBottom;

            // Find min and max values for distance (left Y-axis)
            let allDistances = [];
            graphData.forEach(series => {
                allDistances = allDistances.concat(series.data.map(d => d.y));
            });

            // Convert to miles if needed
            const conversionFactor = currentUnit === 'miles' ? 0.621371 : 1;
            allDistances = allDistances.map(d => d * conversionFactor);

            const minDistance = Math.min(...allDistances);
            const maxDistance = Math.max(...allDistances);
            const distanceRange = maxDistance - minDistance;

            // Find min and max values for elevation (right Y-axis)
            let minElevation = 0;
            let maxElevation = 90;
            let elevationRange = 90;
            if (elevationData.length > 0) {
                let allElevations = [];
                elevationData.forEach(series => {
                    allElevations = allElevations.concat(series.data.map(d => d.y));
                });
                minElevation = Math.min(...allElevations);
                maxElevation = Math.max(...allElevations);
                elevationRange = maxElevation - minElevation;
            }

            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(paddingLeft, paddingTop);
            ctx.lineTo(paddingLeft, canvas.height - paddingBottom);
            ctx.lineTo(canvas.width - paddingRight, canvas.height - paddingBottom);
            ctx.stroke();

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = paddingTop + (graphHeight * i / 5);
                ctx.beginPath();
                ctx.moveTo(paddingLeft, y);
                ctx.lineTo(canvas.width - paddingRight, y);
                ctx.stroke();
            }

            // Draw left Y-axis labels (Distance)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'right';
            const unitSuffix = currentUnit === 'miles' ? 'M mi' : 'M km';
            for (let i = 0; i <= 5; i++) {
                const y = paddingTop + (graphHeight * i / 5);
                const value = maxDistance - (distanceRange * i / 5);
                const label = (value / 1000000).toFixed(2) + ' ' + unitSuffix;
                ctx.fillText(label, paddingLeft - 10, y + 4);
            }

            // Draw right Y-axis and labels (Elevation)
            if (elevationData.length > 0) {
                // Draw right Y-axis line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(canvas.width - paddingRight, paddingTop);
                ctx.lineTo(canvas.width - paddingRight, canvas.height - paddingBottom);
                ctx.stroke();

                // Draw right Y-axis labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'left';
                for (let i = 0; i <= 5; i++) {
                    const y = paddingTop + (graphHeight * i / 5);
                    const value = maxElevation - (elevationRange * i / 5);
                    const label = value.toFixed(1) + '¬∞';
                    ctx.fillText(label, canvas.width - paddingRight + 10, y + 4);
                }

                // Draw horizon line at 0¬∞ if applicable (only in daily view where it makes sense)
                if (currentGraphView === 'daily' && minElevation < 0 && maxElevation > 0) {
                    const horizonY = canvas.height - paddingBottom - ((0 - minElevation) / elevationRange * graphHeight);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(paddingLeft, horizonY);
                    ctx.lineTo(canvas.width - paddingRight, horizonY);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Label the horizon line
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Horizon', paddingLeft + graphWidth / 2, horizonY - 5);
                }
            }

            // Draw X-axis labels (using first series for labels)
            if (graphData[0] && graphData[0].data.length > 0) {
                ctx.textAlign = 'center';
                const step = currentGraphView === 'daily' ? 4 : 2; // Every 4 hours or every 2 months
                for (let i = 0; i < graphData[0].data.length; i += step) {
                    const x = paddingLeft + (graphWidth * i / (graphData[0].data.length - 1));
                    ctx.fillText(graphData[0].data[i].label, x, canvas.height - paddingBottom + 20);
                }
            }

            // Draw current time vertical line
            if (graphData[0] && graphData[0].data.length > 0) {
                const now = new Date();
                const distanceSeries = graphData[0].data;
                let currentIndex = 0;

                if (currentGraphView === 'daily') {
                    // Current hour
                    const currentHour = now.getHours() + now.getMinutes() / 60;
                    currentIndex = currentHour / 24 * (distanceSeries.length - 1);
                } else {
                    // Current month
                    const currentMonth = now.getMonth() + now.getDate() / 31;
                    currentIndex = currentMonth / 12 * (distanceSeries.length - 1);
                }

                // Calculate x position for current time
                const currentX = paddingLeft + (graphWidth * currentIndex / (distanceSeries.length - 1));

                // Draw vertical line at current time
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.4)'; // Semi-transparent orange/yellow
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(currentX, paddingTop);
                ctx.lineTo(currentX, canvas.height - paddingBottom);
                ctx.stroke();
            }

            // Draw distance curves for each series (solid lines)
            graphData.forEach(series => {
                ctx.strokeStyle = series.location.color;
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                for (let i = 0; i < series.data.length; i++) {
                    const x = paddingLeft + (graphWidth * i / (series.data.length - 1));
                    const convertedY = series.data[i].y * conversionFactor;
                    const y = canvas.height - paddingBottom - ((convertedY - minDistance) / distanceRange * graphHeight);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            });

            // Draw elevation curves for each series (dashed lines)
            if (elevationData.length > 0) {
                elevationData.forEach(series => {
                    ctx.strokeStyle = series.location.color;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]); // Dashed line to distinguish from distance
                    ctx.beginPath();
                    for (let i = 0; i < series.data.length; i++) {
                        const x = paddingLeft + (graphWidth * i / (series.data.length - 1));
                        const y = canvas.height - paddingBottom - ((series.data[i].y - minElevation) / elevationRange * graphHeight);

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset
                });
            }

            // Draw current position marker (only for user location - first series)
            if (graphData.length > 0) {
                drawCurrentPositionMarker(minDistance, maxDistance, distanceRange, minElevation, maxElevation, elevationRange, graphWidth, graphHeight, paddingLeft, paddingBottom, conversionFactor);
            }

            // Update legend
            updateLegend();
        }

        // Draw current position marker on graph
        function drawCurrentPositionMarker(minDistance, maxDistance, distanceRange, minElevation, maxElevation, elevationRange, graphWidth, graphHeight, paddingLeft, paddingBottom, conversionFactor) {
            if (!graphData[0] || !graphData[0].data) return;

            const now = new Date();
            const distanceSeries = graphData[0].data;
            let currentIndex = 0;

            if (currentGraphView === 'daily') {
                // Current hour
                const currentHour = now.getHours() + now.getMinutes() / 60;
                currentIndex = currentHour / 24 * (distanceSeries.length - 1);
            } else {
                // Current month
                const currentMonth = now.getMonth() + now.getDate() / 31;
                currentIndex = currentMonth / 12 * (distanceSeries.length - 1);
            }

            // Interpolate distance Y value
            const idx = Math.floor(currentIndex);
            const fraction = currentIndex - idx;
            let distanceValue;
            if (idx >= distanceSeries.length - 1) {
                distanceValue = distanceSeries[distanceSeries.length - 1].y;
            } else {
                distanceValue = distanceSeries[idx].y + (distanceSeries[idx + 1].y - distanceSeries[idx].y) * fraction;
            }

            // Convert to miles if needed
            distanceValue = distanceValue * conversionFactor;

            const x = paddingLeft + (graphWidth * currentIndex / (distanceSeries.length - 1));
            const distanceY = canvas.height - paddingBottom - ((distanceValue - minDistance) / distanceRange * graphHeight);

            // Draw distance marker
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(x, distanceY, 6, 0, 2 * Math.PI);
            ctx.fill();

            // Draw marker outline
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, distanceY, 6, 0, 2 * Math.PI);
            ctx.stroke();

            // Draw elevation marker
            if (elevationData.length > 0 && elevationData[0] && elevationData[0].data) {
                const elevationSeries = elevationData[0].data;
                let elevationValue;
                if (idx >= elevationSeries.length - 1) {
                    elevationValue = elevationSeries[elevationSeries.length - 1].y;
                } else {
                    elevationValue = elevationSeries[idx].y + (elevationSeries[idx + 1].y - elevationSeries[idx].y) * fraction;
                }

                const elevationY = canvas.height - paddingBottom - ((elevationValue - minElevation) / elevationRange * graphHeight);

                // Draw elevation marker
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(x, elevationY, 6, 0, 2 * Math.PI);
                ctx.fill();

                // Draw marker outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, elevationY, 6, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }

        // Set graph view (daily or yearly)
        function setGraphView(view) {
            currentGraphView = view;

            // Update button states
            document.getElementById('dailyViewBtn').classList.remove('active');
            document.getElementById('yearlyViewBtn').classList.remove('active');

            if (view === 'daily') {
                document.getElementById('dailyViewBtn').classList.add('active');
                graphData = generateDailyData();
                elevationData = generateElevationData();
            } else if (view === 'yearly') {
                document.getElementById('yearlyViewBtn').classList.add('active');
                graphData = generateYearlyData();
                elevationData = generateYearlyElevationData();
            }

            drawGraph();
        }

        // Set distance unit (km or miles)
        function setUnit(unit) {
            currentUnit = unit;

            // Update button states
            document.getElementById('kmBtn').classList.remove('active');
            document.getElementById('milesBtn').classList.remove('active');

            if (unit === 'km') {
                document.getElementById('kmBtn').classList.add('active');
            } else {
                document.getElementById('milesBtn').classList.add('active');
            }

            // Save preference to localStorage
            localStorage.setItem('preferredUnit', unit);

            // Immediately update the display
            updateDistance();

            // Redraw graph with new units
            if (graphData.length > 0) {
                drawGraph();
            }
        }

        function requestLocation() {
            const statusEl = document.getElementById('status');
            statusEl.className = 'status loading';
            statusEl.textContent = 'Requesting location access...';

            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(
                    onLocationSuccess,
                    onLocationError,
                    { enableHighAccuracy: true }
                );
            } else {
                statusEl.className = 'status error';
                statusEl.textContent = 'Geolocation is not supported by your browser';
            }
        }

        function onLocationSuccess(position) {
            userLat = position.coords.latitude;
            userLon = position.coords.longitude;

            document.getElementById('status').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';

            // Initialize graphs
            graphData = generateDailyData();
            elevationData = generateElevationData();
            drawGraph();

            // Update immediately
            updateDistance();

            // Update every 100ms for smooth real-time updates
            if (updateInterval) clearInterval(updateInterval);
            updateInterval = setInterval(updateDistance, 100);
        }

        function onLocationError(error) {
            const statusEl = document.getElementById('status');
            statusEl.className = 'status error';

            switch(error.code) {
                case error.PERMISSION_DENIED:
                    statusEl.textContent = 'Location access denied. Please enable location access and refresh.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    statusEl.textContent = 'Location information unavailable.';
                    break;
                case error.TIMEOUT:
                    statusEl.textContent = 'Location request timed out.';
                    break;
                default:
                    statusEl.textContent = 'An unknown error occurred.';
            }
        }

        function updateDistance() {
            const now = new Date();

            // Calculate Earth-Sun distance using simplified astronomical formula
            const dayOfYear = getDayOfYear(now);
            const earthSunDistanceKm = calculateEarthSunDistance(dayOfYear);

            // Calculate user's distance from Sun considering Earth's rotation
            const userDistanceKm = calculateUserDistanceFromSun(
                userLat,
                userLon,
                now,
                earthSunDistanceKm
            );

            // Update display based on selected unit
            let displayValue, unitWord;
            if (currentUnit === 'km') {
                displayValue = userDistanceKm.toLocaleString('en-US', { maximumFractionDigits: 0 });
                unitWord = 'kilometers';
            } else {
                const distanceMiles = userDistanceKm * 0.621371;
                displayValue = distanceMiles.toLocaleString('en-US', { maximumFractionDigits: 0 });
                unitWord = 'miles';
            }

            document.getElementById('distanceValue').textContent = displayValue;
            document.getElementById('distanceUnitLabel').innerHTML =
                `You are <span class="distance-value" style="display: inline; font-size: 1em; margin: 0;">${displayValue}</span> ${unitWord} from the Sun`;

            document.getElementById('localTime').textContent =
                now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            const solarNoonOffset = calculateSolarNoonOffset(userLon, now);
            document.getElementById('solarNoon').textContent = solarNoonOffset;

            document.getElementById('coordinates').textContent =
                `${userLat.toFixed(4)}¬∞, ${userLon.toFixed(4)}¬∞`;

            // Update graph with current position
            if (graphData.length > 0) {
                drawGraph();
            }
        }

        function getDayOfYear(date) {
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay);
        }

        function calculateEarthSunDistance(dayOfYear) {
            // Earth's orbit is elliptical with perihelion ~Jan 3 and aphelion ~July 4
            // Average distance (1 AU) = 149,597,870.7 km
            // Eccentricity of Earth's orbit ‚âà 0.0167

            const AU = 149597870.7; // km
            const eccentricity = 0.0167;

            // Approximate orbital position (0 = perihelion, around Jan 3)
            const perihelionDay = 3;
            const daysSincePerihelion = (dayOfYear - perihelionDay + 365) % 365;
            const meanAnomaly = (2 * Math.PI * daysSincePerihelion) / 365.25;

            // Simplified distance calculation
            const distance = AU * (1 - eccentricity * Math.cos(meanAnomaly));

            return distance;
        }

        function calculateUserDistanceFromSun(lat, lon, time, earthSunDistance) {
            // Convert latitude to radians
            const latRad = lat * Math.PI / 180;

            // Earth's radius in km
            const earthRadius = 6371;

            // Calculate hour angle (Earth's rotation)
            const hours = time.getUTCHours();
            const minutes = time.getUTCMinutes();
            const seconds = time.getUTCSeconds();
            const milliseconds = time.getUTCMilliseconds();

            // Decimal hours since midnight UTC
            const decimalHours = hours + minutes/60 + seconds/3600 + milliseconds/3600000;

            // Solar hour angle for the longitude (15 degrees per hour)
            // At solar noon (12:00 solar time), the user is closest to the Sun
            const solarHourAngle = ((decimalHours - 12) * 15 + lon) * Math.PI / 180;

            // User's distance from Earth's center projected toward the Sun
            const userOffsetFromCenter = earthRadius * Math.cos(latRad) * Math.cos(solarHourAngle);

            // Total distance from user to Sun
            const userDistanceFromSun = earthSunDistance - userOffsetFromCenter;

            return userDistanceFromSun;
        }

        function isUserFacingSun(lat, lon, time) {
            const hours = time.getUTCHours();
            const minutes = time.getUTCMinutes();
            const decimalHours = hours + minutes/60;

            // Calculate solar hour angle
            const solarHourAngle = ((decimalHours - 12) * 15 + lon);

            // Normalize to -180 to 180
            let angle = solarHourAngle % 360;
            if (angle > 180) angle -= 360;
            if (angle < -180) angle += 360;

            // If angle is between -90 and 90, user is facing the Sun (daytime)
            return angle >= -90 && angle <= 90;
        }

        function calculateSolarNoonOffset(lon, time) {
            const hours = time.getUTCHours();
            const minutes = time.getUTCMinutes();
            const decimalHours = hours + minutes/60;

            // Solar noon in UTC for this longitude
            const solarNoonUTC = 12 - (lon / 15);

            // Offset from solar noon
            let offset = decimalHours - solarNoonUTC;

            // Normalize to -12 to 12
            while (offset > 12) offset -= 24;
            while (offset < -12) offset += 24;

            const absOffset = Math.abs(offset);
            const hrs = Math.floor(absOffset);
            const mins = Math.round((absOffset - hrs) * 60);

            if (Math.abs(offset) < 0.05) {
                return 'At solar noon';
            }

            const timeStr = hrs > 0 ? `${hrs}h ${mins}m` : `${mins}m`;
            return offset > 0 ? `+${timeStr}` : `-${timeStr}`;
        }

        // Calculate solar declination (angle of sun relative to equator)
        function calculateSolarDeclination(date) {
            // Solar declination varies from +23.45¬∞ (summer solstice) to -23.45¬∞ (winter solstice)
            // Formula: Œ¥ = 23.45¬∞ √ó sin(360¬∞ √ó (284 + N) / 365)
            const dayOfYear = getDayOfYear(date);
            const declination = 23.45 * Math.sin((360 * (284 + dayOfYear) / 365) * Math.PI / 180);
            return declination;
        }

        // Calculate solar elevation angle (altitude above horizon)
        function calculateSolarElevation(lat, lon, date) {
            // Formula: sin(Œ±) = sin(œÜ) √ó sin(Œ¥) + cos(œÜ) √ó cos(Œ¥) √ó cos(H)
            // Where:
            //   Œ± = solar elevation angle
            //   œÜ = observer's latitude
            //   Œ¥ = solar declination
            //   H = solar hour angle

            const latRad = lat * Math.PI / 180;
            const declination = calculateSolarDeclination(date);
            const declinationRad = declination * Math.PI / 180;

            // Calculate solar hour angle
            const hours = date.getUTCHours();
            const minutes = date.getUTCMinutes();
            const seconds = date.getUTCSeconds();
            const milliseconds = date.getUTCMilliseconds();
            const decimalHours = hours + minutes/60 + seconds/3600 + milliseconds/3600000;
            const solarHourAngle = ((decimalHours - 12) * 15 + lon) * Math.PI / 180;

            // Calculate elevation angle
            const sinElevation = Math.sin(latRad) * Math.sin(declinationRad) +
                                Math.cos(latRad) * Math.cos(declinationRad) * Math.cos(solarHourAngle);
            const elevation = Math.asin(sinElevation) * 180 / Math.PI;

            return elevation;
        }

        // Modal functions
        function openModal() {
            document.getElementById('formulaModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('formulaModal').style.display = 'none';
        }

        function closeModalOnOutsideClick(event) {
            const modal = document.getElementById('formulaModal');
            if (event.target === modal) {
                closeModal();
            }
        }

        // Allow ESC key to close modal
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeModal();
            }
        });

        // Update legend display
        function updateLegend() {
            const legendContainer = document.getElementById('graphLegend');

            if (graphData.length === 0) {
                legendContainer.innerHTML = '';
                return;
            }

            let legendHTML = '';

            // Add note about line styles (both views now show elevation)
            if (elevationData.length > 0) {
                legendHTML += '<div style="width: 100%; text-align: center; font-size: 0.8em; margin-bottom: 8px; opacity: 0.9;">Solid = Distance | Dashed = Elevation</div>';
            }

            // Add location items
            legendHTML += graphData.map(series => `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: ${series.location.color}"></div>
                    <span>${series.location.label}</span>
                </div>
            `).join('');

            legendContainer.innerHTML = legendHTML;
        }

        // Add comparison location
        function addComparisonLocation() {
            const select = document.getElementById('citySelect');
            const selectedIndex = select.value;
            const customLat = document.getElementById('customLat').value;
            const customLon = document.getElementById('customLon').value;

            // Check max locations first
            if (comparisonLocations.length >= MAX_LOCATIONS) {
                alert(`Maximum ${MAX_LOCATIONS} comparison locations allowed`);
                return;
            }

            let location;

            // Check if custom coordinates are provided
            if (customLat !== '' && customLon !== '') {
                // Validate coordinates
                const lat = parseFloat(customLat);
                const lon = parseFloat(customLon);

                if (isNaN(lat) || isNaN(lon)) {
                    alert('Please enter valid numeric coordinates');
                    return;
                }

                if (lat < -90 || lat > 90) {
                    alert('Latitude must be between -90 and 90');
                    return;
                }

                if (lon < -180 || lon > 180) {
                    alert('Longitude must be between -180 and 180');
                    return;
                }

                // Check if location is already added
                const alreadyAdded = comparisonLocations.some(loc =>
                    Math.abs(loc.lat - lat) < 0.0001 && Math.abs(loc.lon - lon) < 0.0001
                );

                if (alreadyAdded) {
                    alert('This location has already been added');
                    return;
                }

                // Create location object with custom coordinates
                const label = `${lat.toFixed(4)}¬∞, ${lon.toFixed(4)}¬∞`;
                location = {
                    lat: lat,
                    lon: lon,
                    label: label,
                    color: colorPalette[comparisonLocations.length + 1]
                };

                // Clear custom input fields
                document.getElementById('customLat').value = '';
                document.getElementById('customLon').value = '';

            } else if (selectedIndex !== '') {
                // Use city from dropdown
                const selectedCity = cities[parseInt(selectedIndex)];

                // Check if city is already added
                const alreadyAdded = comparisonLocations.some(loc =>
                    loc.lat === selectedCity.lat && loc.lon === selectedCity.lon
                );

                if (alreadyAdded) {
                    alert('This city has already been added');
                    return;
                }

                // Create location object from city
                location = {
                    lat: selectedCity.lat,
                    lon: selectedCity.lon,
                    label: selectedCity.name,
                    color: colorPalette[comparisonLocations.length + 1]
                };

                // Reset dropdown
                select.value = '';

            } else {
                // Neither city nor coordinates provided
                alert('Please either select a city or enter coordinates');
                return;
            }

            // Add location
            comparisonLocations.push(location);

            // Update display
            updateComparisonLocationsDisplay();
            updateGraphData();
        }

        // Remove comparison location
        function removeComparisonLocation(index) {
            comparisonLocations.splice(index, 1);
            // Reassign colors
            comparisonLocations.forEach((loc, i) => {
                loc.color = colorPalette[i + 1];
            });
            updateComparisonLocationsDisplay();
            updateGraphData();
        }

        // Update comparison locations display
        function updateComparisonLocationsDisplay() {
            const container = document.getElementById('comparisonLocations');

            if (comparisonLocations.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = comparisonLocations.map((loc, index) => `
                <div class="location-item" style="border-left-color: ${loc.color}">
                    <span class="location-label">${loc.label}</span>
                    <button class="remove-btn" onclick="removeComparisonLocation(${index})">Remove</button>
                </div>
            `).join('');
        }

        // Update graph data with all locations
        function updateGraphData() {
            if (currentGraphView === 'daily') {
                graphData = generateDailyData();
                elevationData = generateElevationData();
            } else if (currentGraphView === 'yearly') {
                graphData = generateYearlyData();
                elevationData = generateYearlyElevationData();
            }
            drawGraph();
        }
    </script>
</body>
</html>
